// lib/main.dart
// Upravené: rýchlejšie tempo zápasov (spawn intervaly, burst, shield, buffer, passive interval, AI delay).
// Zachované: všetky predchádzajúce mechaniky (link rules, MAX transit, guard, unit types).
import 'dart:async';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

// ================== CONFIG ==================
const int MAX_UNITS = 40;
const double UNIT_BASE_SPEED = 220.0; // px/s
const double TOUCH_RADIUS = 36.0;
const double COLLISION_DISTANCE = 8.0;
const int BURST_DELAY_MS = 140;

// Tuning suggested by analysis (aplikované)
const int MAX_ARRIVAL_BUFFER_MS = 30; // buffer for MAX arrivals (very small)
const double PASSIVE_PRODUCTION_INTERVAL = 2.0; // seconds (was 4.0)
const double AI_START_DELAY_SECONDS = 0.5; // reduce player advantage
// ============================================

enum Owner { player, enemy, neutral }

class UnitType {
  final String id;
  final String name;
  final double spawnRateModifier; // multiplier to spawn interval (lower = faster)
  final double speedMultiplier; // movement multiplier
  final double shieldChanceAdd; // additive to shield chance
  final double burstChanceAdd; // additive to burst chance

  const UnitType({
    required this.id,
    required this.name,
    required this.spawnRateModifier,
    required this.speedMultiplier,
    required this.shieldChanceAdd,
    required this.burstChanceAdd,
  });
}

const List<UnitType> unitTypes = [
  UnitType(id: 'infantry', name: 'Infantry', spawnRateModifier: 1.0, speedMultiplier: 1.0, shieldChanceAdd: 0.0, burstChanceAdd: 0.0),
  UnitType(id: 'scout', name: 'Scout', spawnRateModifier: 0.85, speedMultiplier: 1.35, shieldChanceAdd: -0.02, burstChanceAdd: -0.02),
  UnitType(id: 'heavy', name: 'Heavy', spawnRateModifier: 1.25, speedMultiplier: 0.8, shieldChanceAdd: 0.03, burstChanceAdd: 0.08),
  UnitType(id: 'tank', name: 'Tank', spawnRateModifier: 1.4, speedMultiplier: 0.7, shieldChanceAdd: 0.05, burstChanceAdd: 0.10),
];

// New tuned base probs / intervals (changed to make matches faster)
double baseShieldChance(int units) {
  if (units >= 30) return 0.18;
  if (units >= 10) return 0.08;
  return 0.03;
}

double baseBurstChance(int units) {
  if (units >= 30) return 0.60;
  if (units >= 10) return 0.28;
  return 0.12;
}

double baseSpawnInterval(int units) {
  if (units >= 30) return 0.18;
  if (units >= 10) return 0.35;
  return 0.5;
}

// ========== App entry ==========
void main() {
  WidgetsFlutterBinding.ensureInitialized();
  SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp]);
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return const MaterialApp(debugShowCheckedModeBanner: false, home: GameScreen());
  }
}

// ========== Game model ==========
class Tower {
  final int id;
  Offset pos;
  Owner owner;
  int units;
  final bool isGuard;
  int unitTypeIndex;
  int level;

  Tower({
    required this.id,
    required this.pos,
    required this.owner,
    required this.units,
    this.isGuard = false,
    this.unitTypeIndex = 0,
    this.level = 1,
  });

  bool get isMax => units >= MAX_UNITS;

  int maxLinks() {
    if (units >= 30) return 3;
    if (units >= 10) return 2;
    return 1;
  }

  double guardRange() {
    if (units >= 30) return 180.0;
    if (units >= 10) return 130.0;
    return 90.0;
  }

  double guardInterval() {
    if (units >= 30) return 0.7;
    if (units >= 10) return 1.0;
    return 1.2;
  }

  int guardShots() {
    if (units >= 30) return 2;
    return 1;
  }

  UnitType get unitType => unitTypes[unitTypeIndex];
}

class Link {
  final int from;
  final int to;
  double laneOffset;
  Timer? timer;
  double accum = 0.0;
  Link({required this.from, required this.to, required this.laneOffset});
}

class Unit {
  int from;
  int to;
  Owner owner;
  Offset pos;
  int hp;
  bool shield;
  double speedMult;

  Unit({
    required this.from,
    required this.to,
    required this.owner,
    required this.pos,
    this.hp = 1,
    this.shield = false,
    this.speedMult = 1.0,
  });
}

class _BufferedArrival {
  final Owner owner;
  final int points;
  final bool shield;
  final int fromId;
  _BufferedArrival({required this.owner, required this.points, required this.shield, required this.fromId});
}

// ========== GameScreen ==========
class GameScreen extends StatefulWidget {
  const GameScreen({super.key});
  @override
  State<GameScreen> createState() => _GameScreenState();
}

class _GameScreenState extends State<GameScreen> {
  final Random _rnd = Random();

  final List<Tower> towers = [];
  final List<Link> links = [];
  final List<Unit> units = [];

  final List<Unit> _pendingUnits = [];

  final Map<int, List<_BufferedArrival>> _arrivalBuffer = {};
  final Map<int, Timer?> _arrivalBufferTimer = {};

  Timer? _globalTicker;
  double _accumPassive = 0.0;

  int? dragFrom;
  Offset? dragPos;
  bool eraseMode = false;

  Timer? _aiTimer;
  final Map<int, double> _guardAccum = {};

  @override
  void initState() {
    super.initState();

    towers.addAll([
      Tower(id: 0, pos: const Offset(200, 150), owner: Owner.player, units: 5, unitTypeIndex: 0, level: 1),
      Tower(id: 1, pos: const Offset(100, 350), owner: Owner.neutral, units: 8, isGuard: true, unitTypeIndex: 2, level: 1),
      Tower(id: 2, pos: const Offset(300, 350), owner: Owner.neutral, units: 12, unitTypeIndex: 0, level: 1),
      Tower(id: 3, pos: const Offset(200, 560), owner: Owner.enemy, units: 15, unitTypeIndex: 0, level: 1),
    ]);

    for (final t in towers) _guardAccum[t.id] = 0.0;

    _globalTicker = Timer.periodic(const Duration(milliseconds: 16), (_) {
      _tick(0.016);
    });

    final jitter = _rnd.nextDouble() * 0.4;
    Future.delayed(Duration(milliseconds: ((AI_START_DELAY_SECONDS + jitter) * 1000).round()), () {
      _aiTimer = Timer.periodic(const Duration(seconds: 2), (_) {
        _runAI();
      });
    });
  }

  @override
  void dispose() {
    for (final l in List<Link>.from(links)) l.timer?.cancel();
    for (final t in _arrivalBufferTimer.values) t?.cancel();
    _globalTicker?.cancel();
    _aiTimer?.cancel();
    super.dispose();
  }

  void _enqueueUnit(int fromId, int toId, {int hp = 1, bool shield = false, double laneOffset = 0.0, double speedMult = 1.0}) {
    final src = towers.firstWhere((t) => t.id == fromId);
    final dst = towers.firstWhere((t) => t.id == toId);
    final spawnPos = _spawnPositionWithOffset(src.pos, dst.pos, laneOffset);
    _pendingUnits.add(Unit(from: fromId, to: toId, owner: src.owner, pos: spawnPos, hp: hp, shield: shield, speedMult: speedMult));
  }

  void _startLinkTimer(Link link) {
    link.timer?.cancel();
    link.timer = Timer.periodic(const Duration(milliseconds: 120), (_) {
      if (!mounted) return;
      final srcTower = towers.firstWhere((t) => t.id == link.from);
      double baseInterval = baseSpawnInterval(srcTower.units);
      final levelModifier = 1.0 - (srcTower.level - 1) * 0.02;
      final typeModifier = srcTower.unitType.spawnRateModifier;
      final effectiveInterval = max(0.12, baseInterval * typeModifier * levelModifier);
      link.accum += 0.12;
      if (link.accum >= effectiveInterval) {
        link.accum = 0.0;
        double shieldP = baseShieldChance(srcTower.units) + srcTower.unitType.shieldChanceAdd + srcTower.level * 0.004;
        double burstP = baseBurstChance(srcTower.units) + srcTower.unitType.burstChanceAdd + srcTower.level * 0.006;
        shieldP = shieldP.clamp(0.0, 0.9);
        burstP = burstP.clamp(0.0, 0.99);

        final isShielded = _rnd.nextDouble() < shieldP;
        final isBurst = _rnd.nextDouble() < burstP;
        final speedMult = srcTower.unitType.speedMultiplier;

        if (isBurst) {
          final hpVal = (isShielded && srcTower.unitType.id == 'heavy') ? 2 : 1;
          _enqueueUnit(link.from, link.to, hp: hpVal, shield: isShielded, laneOffset: link.laneOffset, speedMult: speedMult);
          Future.delayed(Duration(milliseconds: BURST_DELAY_MS), () {
            _enqueueUnit(link.from, link.to, hp: hpVal, shield: isShielded, laneOffset: link.laneOffset, speedMult: speedMult);
          });
        } else {
          final hpVal = (isShielded && srcTower.unitType.id == 'heavy') ? 2 : 1;
          _enqueueUnit(link.from, link.to, hp: hpVal, shield: isShielded, laneOffset: link.laneOffset, speedMult: speedMult);
        }
      }
    });
  }

  void _tick(double dt) {
    if (_pendingUnits.isNotEmpty) {
      units.addAll(_pendingUnits);
      _pendingUnits.clear();
    }

    for (final u in units) {
      final dst = towers.firstWhere((t) => t.id == u.to);
      final dir = dst.pos - u.pos;
      final dist = dir.distance;
      if (dist > 0.0001) {
        final move = UNIT_BASE_SPEED * u.speedMult * dt;
        u.pos = u.pos + (dir / dist) * min(move, dist);
      }
    }

    final Set<Unit> toRemoveByCollision = {};
    final Map<String, List<Unit>> bySegment = {};
    for (final u in units) {
      final a = u.from;
      final b = u.to;
      final key = (a < b) ? '$a-$b' : '$b-$a';
      bySegment.putIfAbsent(key, () => []).add(u);
    }

    for (final entry in bySegment.entries) {
      final segUnits = entry.value;
      final Map<String, List<Unit>> dirMap = {};
      for (final u in segUnits) {
        final k = '${u.from}->${u.to}';
        dirMap.putIfAbsent(k, () => []).add(u);
      }
      final keys = dirMap.keys.toList();
      for (int i = 0; i < keys.length; i++) {
        for (int j = i + 1; j < keys.length; j++) {
          final k1 = keys[i];
          final k2 = keys[j];
          final parts1 = k1.split('->');
          final parts2 = k2.split('->');
          final f1 = int.parse(parts1[0]);
          final t1 = int.parse(parts1[1]);
          final f2 = int.parse(parts2[0]);
          final t2 = int.parse(parts2[1]);
          if (!(f1 == t2 && t1 == f2)) continue;
          final listA = dirMap[k1]!;
          final listB = dirMap[k2]!;
          for (final uA in listA) {
            if (toRemoveByCollision.contains(uA)) continue;
            for (final uB in listB) {
              if (toRemoveByCollision.contains(uB)) continue;
              if (uA.owner == uB.owner) continue;
              final d = (uA.pos - uB.pos).distance;
              if (d <= COLLISION_DISTANCE) {
                _applyDamageToUnit(uA);
                _applyDamageToUnit(uB);
                if (uA.hp <= 0) toRemoveByCollision.add(uA);
                if (uB.hp <= 0) toRemoveByCollision.add(uB);
                break;
              }
            }
          }
        }
      }
    }
    if (toRemoveByCollision.isNotEmpty) units.removeWhere((u) => toRemoveByCollision.contains(u));

    final List<Unit> arrived = [];
    for (final u in units) {
      final dst = towers.firstWhere((t) => t.id == u.to);
      final dist = (dst.pos - u.pos).distance;
      if (dist < 4.0) arrived.add(u);
    }

    final List<Unit> spawnedFromArrivals = [];
    if (arrived.isNotEmpty) {
      for (final u in arrived) {
        final dst = towers.firstWhere((t) => t.id == u.to);
        if (dst.isMax && links.any((l) => l.from == dst.id)) {
          _bufferArrival(dst.id, _BufferedArrival(owner: u.owner, points: u.hp, shield: u.shield, fromId: u.from));
        } else {
          final spawned = _onUnitArrive(u, dst, deliverPoints: u.hp);
          if (spawned.isNotEmpty) spawnedFromArrivals.addAll(spawned);
        }
      }
      units.removeWhere((u) => arrived.contains(u));
    }
    if (spawnedFromArrivals.isNotEmpty) units.addAll(spawnedFromArrivals);

    final Set<Unit> toRemoveByGuards = {};
    final List<_TowerDamage> towerDamages = [];
    for (final tower in towers.where((t) => t.isGuard)) {
      _guardAccum[tower.id] = (_guardAccum[tower.id] ?? 0) + dt;
      final interval = tower.guardInterval();
      if (_guardAccum[tower.id]! >= interval) {
        _guardAccum[tower.id] = 0.0;
        final range = tower.guardRange();
        final candidates = units.where((u) => u.owner != tower.owner && (u.pos - tower.pos).distance <= range).toList();
        if (candidates.isNotEmpty) {
          candidates.sort((a, b) => (a.pos - tower.pos).distance.compareTo((b.pos - tower.pos).distance));
          final shots = tower.guardShots();
          for (int i = 0; i < min(shots, candidates.length); i++) {
            final target = candidates[i];
            _applyDamageToUnit(target);
            if (target.hp <= 0) toRemoveByGuards.add(target);
          }
        } else {
          final towerTargets = towers.where((tt) => tt.id != tower.id && tt.owner != tower.owner && (tt.pos - tower.pos).distance <= range).toList();
          if (towerTargets.isNotEmpty) {
            towerTargets.sort((a, b) => (a.pos - tower.pos).distance.compareTo((b.pos - tower.pos).distance));
            final shots = tower.guardShots();
            for (int i = 0; i < min(shots, towerTargets.length); i++) {
              towerDamages.add(_TowerDamage(targetId: towerTargets[i].id, damage: 1, shooterOwner: tower.owner));
            }
          }
        }
      }
    }
    if (toRemoveByGuards.isNotEmpty) units.removeWhere((u) => toRemoveByGuards.contains(u));
    if (towerDamages.isNotEmpty) {
      for (final dmg in towerDamages) {
        final tgt = towers.firstWhere((t) => t.id == dmg.targetId);
        tgt.units -= dmg.damage;
        if (tgt.units <= 0) {
          tgt.owner = dmg.shooterOwner;
          tgt.units = 1;
        }
        if (tgt.units < 0) tgt.units = 0;
      }
    }

    _accumPassive += dt;
    if (_accumPassive >= PASSIVE_PRODUCTION_INTERVAL) {
      _accumPassive = 0.0;
      for (final t in towers) {
        if (t.isGuard) continue;
        final hasOutgoing = links.any((l) => l.from == t.id);
        if (!hasOutgoing && !t.isMax) t.units = min(t.units + 1, MAX_UNITS);
      }
    }

    setState(() {});
  }

  void _bufferArrival(int dstId, _BufferedArrival arrival) {
    _arrivalBuffer.putIfAbsent(dstId, () => []).add(arrival);
    _arrivalBufferTimer[dstId]?.cancel();
    _arrivalBufferTimer[dstId] = Timer(Duration(milliseconds: MAX_ARRIVAL_BUFFER_MS), () {
      _processArrivalBuffer(dstId);
    });
  }

  void _processArrivalBuffer(int dstId) {
    final buffer = _arrivalBuffer[dstId];
    _arrivalBuffer[dstId] = [];
    _arrivalBufferTimer[dstId]?.cancel();
    _arrivalBufferTimer.remove(dstId);
    if (buffer == null || buffer.isEmpty) return;

    final dst = towers.firstWhere((t) => t.id == dstId);
    final Map<Owner, int> totals = {};
    for (final b in buffer) {
      totals[b.owner] = (totals[b.owner] ?? 0) + b.points;
    }

    final friendlyPoints = totals[dst.owner] ?? 0;
    if (friendlyPoints > 0) {
      dst.units = min(dst.units + friendlyPoints, MAX_UNITS);
    }

    int sumEnemy = 0;
    Owner? strongest;
    int strongestPoints = 0;
    totals.forEach((owner, pts) {
      if (owner != dst.owner) {
        sumEnemy += pts;
        if (pts > strongestPoints) {
          strongestPoints = pts;
          strongest = owner;
        }
      }
    });

    if (strongest != null && strongestPoints > dst.units) {
      final leftover = strongestPoints - dst.units;
      dst.owner = strongest!;
      dst.units = max(1, leftover);
    } else {
      if (sumEnemy > 0) {
        dst.units = max(0, dst.units - sumEnemy);
      }
      final outgoing = links.where((l) => l.from == dst.id).toList();
      if (outgoing.isNotEmpty) {
        for (final b in buffer) {
          for (final l in outgoing) {
            final tgt = towers.firstWhere((t) => t.id == l.to);
            final spawnPos = _spawnPositionWithOffset(dst.pos, tgt.pos, l.laneOffset);
            for (int i = 0; i < b.points; i++) {
              units.add(Unit(from: dst.id, to: l.to, owner: b.owner, pos: spawnPos, hp: 1, shield: false, speedMult: 1.0));
            }
          }
        }
      }
    }
  }

  void _applyDamageToUnit(Unit u) {
    if (u.shield) {
      u.shield = false;
      return;
    }
    u.hp -= 1;
  }

  List<Unit> _onUnitArrive(Unit u, Tower dst, {int deliverPoints = 1}) {
    final List<Unit> spawned = [];
    if (dst.isMax && links.any((l) => l.from == dst.id)) {
      return spawned;
    }
    if (u.owner == dst.owner) {
      dst.units = min(dst.units + deliverPoints, MAX_UNITS);
    } else {
      if (dst.units > deliverPoints) {
        dst.units -= deliverPoints;
      } else {
        final leftover = deliverPoints - dst.units;
        dst.owner = u.owner;
        dst.units = max(1, leftover);
      }
    }
    return spawned;
  }

  Offset _spawnPositionWithOffset(Offset src, Offset dst, double laneOffset) {
    final dir = dst - src;
    final dist = dir.distance;
    if (dist == 0) return src;
    final unit = dir / dist;
    final perp = Offset(-unit.dy, unit.dx);
    return src + perp * laneOffset;
  }

  int? _towerAt(Offset p) {
    for (final t in towers) {
      if ((t.pos - p).distance <= TOUCH_RADIUS) return t.id;
    }
    return null;
  }

  void _createLink(int fromId, int toId) {
    final fromTower = towers.firstWhere((t) => t.id == fromId);
    if (fromTower.isGuard) return;

    final currentOutgoing = links.where((l) => l.from == fromId).length;
    if (currentOutgoing >= fromTower.maxLinks()) return;
    if (links.any((l) => l.from == fromId && l.to == toId)) return;

    final reverseIndex = links.indexWhere((l) => l.from == toId && l.to == fromId);
    if (reverseIndex != -1) {
      final reverseLink = links[reverseIndex];
      final reverseOwner = towers.firstWhere((t) => t.id == reverseLink.from).owner;
      final newOwner = towers.firstWhere((t) => t.id == fromId).owner;
      if (reverseOwner == newOwner) {
        links[reverseIndex].timer?.cancel();
        links.removeAt(reverseIndex);
      } else {
        // owners differ => keep both links (combat)
      }
    }

    final newCount = currentOutgoing + 1;
    final spacing = 12.0;
    final index = currentOutgoing;
    final offset = (index - (newCount - 1) / 2.0) * spacing;

    final link = Link(from: fromId, to: toId, laneOffset: offset);
    links.add(link);

    _startLinkTimer(link);
  }

  void _removeLinkAt(int index) {
    if (index < 0 || index >= links.length) return;
    final l = links[index];
    l.timer?.cancel();
    links.removeAt(index);
  }

  void _tryRemoveLinkAtPoint(Offset p) {
    const threshold = 12.0;
    for (int i = 0; i < links.length; i++) {
      final l = links[i];
      final a = towers.firstWhere((t) => t.id == l.from).pos;
      final b = towers.firstWhere((t) => t.id == l.to).pos;
      final d = _distToSegment(p, a, b);
      if (d < threshold) {
        _removeLinkAt(i);
        return;
      }
    }
  }

  double _distToSegment(Offset p, Offset a, Offset b) {
    final ap = p - a;
    final ab = b - a;
    final denom = ab.dx * ab.dx + ab.dy * ab.dy;
    if (denom == 0) return (p - a).distance;
    final t = (ap.dx * ab.dx + ap.dy * ab.dy) / denom;
    final tt = t.clamp(0.0, 1.0);
    final proj = Offset(a.dx + ab.dx * tt, a.dy + ab.dy * tt);
    return (p - proj).distance;
  }

  void _runAI() {
    for (final src in towers.where((t) => t.owner == Owner.enemy && !t.isGuard)) {
      final currentOutgoing = links.where((l) => l.from == src.id).length;
      final allowed = src.maxLinks();
      if (currentOutgoing >= allowed) continue;

      final candidates = towers.where((t) => t.id != src.id && t.owner != Owner.enemy).toList();
      if (candidates.isEmpty) continue;

      double bestScore = double.infinity;
      Tower? best;
      for (final cand in candidates) {
        if (links.any((l) => l.from == src.id && l.to == cand.id)) continue;
        final dist = (cand.pos - src.pos).distance;
        final score = dist * 0.6 + cand.units * 1.4;
        if (score < bestScore) {
          bestScore = score;
          best = cand;
        }
      }
      if (best != null) _createLink(src.id, best.id);
    }
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onPanStart: (details) {
        final p = details.localPosition;
        final tId = _towerAt(p);
        if (tId != null) {
          final tower = towers.firstWhere((t) => t.id == tId);
          if (tower.isGuard) {
            dragFrom = null;
            eraseMode = false;
            dragPos = null;
            setState(() {});
            return;
          }
          dragFrom = tId;
          eraseMode = false;
          dragPos = p;
        } else {
          dragFrom = null;
          eraseMode = true;
          dragPos = p;
          _tryRemoveLinkAtPoint(p);
        }
        setState(() {});
      },
      onPanUpdate: (details) {
        dragPos = details.localPosition;
        if (eraseMode) _tryRemoveLinkAtPoint(dragPos!);
        setState(() {});
      },
      onPanEnd: (details) {
        if (!eraseMode && dragFrom != null && dragPos != null) {
          final toId = _towerAt(dragPos!);
          if (toId != null && toId != dragFrom) _createLink(dragFrom!, toId);
        }
        dragFrom = null;
        dragPos = null;
        eraseMode = false;
        setState(() {});
      },
      child: Scaffold(
        backgroundColor: const Color(0xFF0B0B0B),
        body: CustomPaint(
          size: Size.infinite,
          painter: GamePainter(
            towers: towers,
            links: links,
            units: units,
            dragFrom: dragFrom,
            dragPos: dragPos,
            eraseMode: eraseMode,
          ),
        ),
      ),
    );
  }
}

class _TowerDamage {
  final int targetId;
  final int damage;
  final Owner shooterOwner;
  _TowerDamage({required this.targetId, required this.damage, required this.shooterOwner});
}

// ========== Painter ==========
class GamePainter extends CustomPainter {
  final List<Tower> towers;
  final List<Link> links;
  final List<Unit> units;
  final int? dragFrom;
  final Offset? dragPos;
  final bool eraseMode;

  GamePainter({
    required this.towers,
    required this.links,
    required this.units,
    required this.dragFrom,
    required this.dragPos,
    required this.eraseMode,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final linkPaint = Paint()..strokeWidth = 3.0;
    final unitPaint = Paint();

    linkPaint.color = Colors.white24;
    for (final l in links) {
      final a = towers.firstWhere((t) => t.id == l.from).pos;
      final b = towers.firstWhere((t) => t.id == l.to).pos;
      canvas.drawLine(a, b, linkPaint);
      _drawArrow(canvas, a, b);
    }

    for (final t in towers.where((t) => t.isGuard)) {
      final range = t.guardRange();
      final rPaint = Paint()..color = Colors.orange.withOpacity(0.12);
      canvas.drawCircle(t.pos, range, rPaint);
    }

    if (dragFrom != null && dragPos != null) {
      final a = towers.firstWhere((t) => t.id == dragFrom).pos;
      linkPaint.color = eraseMode ? Colors.redAccent : Colors.yellowAccent;
      canvas.drawLine(a, dragPos!, linkPaint..strokeWidth = 3.0);
    }

    for (final u in units) {
      if (u.owner == Owner.player) unitPaint.color = Colors.lightBlueAccent;
      else if (u.owner == Owner.enemy) unitPaint.color = Colors.redAccent;
      else unitPaint.color = Colors.white70;

      double r = 4.0;
      if (u.hp > 1) r = 6.0;
      if (u.hp > 1) {
        unitPaint.color = const Color(0xFFFFD700);
      }
      canvas.drawCircle(u.pos, r, unitPaint);

      if (u.shield) {
        final shieldPaint = Paint()
          ..color = Colors.yellow.withOpacity(0.95)
          ..style = PaintingStyle.stroke
          ..strokeWidth = 1.6;
        canvas.drawCircle(u.pos, r + 3, shieldPaint);
      }
    }

    for (final t in towers) {
      if (t.isGuard) {
        canvas.drawCircle(t.pos, 30.0, Paint()..color = Colors.grey.shade700);
        Color turretColor;
        switch (t.owner) {
          case Owner.player:
            turretColor = Colors.blueAccent;
            break;
          case Owner.enemy:
            turretColor = Colors.redAccent;
            break;
          case Owner.neutral:
          default:
            turretColor = Colors.orangeAccent;
        }
        final rect = Rect.fromCenter(center: t.pos - const Offset(0, 8), width: 18, height: 18);
        canvas.drawRect(rect, Paint()..color = turretColor);
        final tp = TextPainter(
          text: TextSpan(text: t.isMax ? 'MAX' : '${t.units}', style: const TextStyle(color: Colors.white, fontSize: 12, fontWeight: FontWeight.bold)),
          textDirection: TextDirection.ltr,
        )..layout();
        tp.paint(canvas, t.pos + const Offset(-12, 22));
      } else {
        Color color;
        switch (t.owner) {
          case Owner.player:
            color = Colors.blue;
            break;
          case Owner.enemy:
            color = Colors.red;
            break;
          case Owner.neutral:
          default:
            color = Colors.grey;
        }
        canvas.drawCircle(t.pos, 30.0, Paint()..color = color);
        final tp = TextPainter(
          text: TextSpan(text: t.isMax ? 'MAX' : '${t.units}', style: const TextStyle(color: Colors.white, fontSize: 16, fontWeight: FontWeight.bold)),
          textDirection: TextDirection.ltr,
        )..layout();
        tp.paint(canvas, t.pos - Offset(tp.width / 2, tp.height / 2));
      }

      final ut = t.unitType;
      final label = '${ut.name} L${t.level}';
      final lt = TextPainter(text: TextSpan(text: label, style: const TextStyle(color: Colors.white70, fontSize: 10)), textDirection: TextDirection.ltr)
        ..layout();
      lt.paint(canvas, t.pos + Offset(-lt.width / 2, 34));
    }

    // Debug HUD (top-right): spawn interval / burst% / shield% for each tower
    const padding = 8.0;
    final hudPaint = Paint()..color = Colors.black54;
    final hudX = size.width - 220.0;
    final hudY = 16.0;
    final hudWidth = 208.0;
    final hudHeight = min(200.0, 20.0 * towers.length + 12.0);
    final hudRect = Rect.fromLTWH(hudX, hudY, hudWidth, hudHeight);
    canvas.drawRRect(RRect.fromRectAndRadius(hudRect, const Radius.circular(8)), hudPaint);

    double y = hudY + 6.0;
    for (final t in towers) {
      final spawnBase = baseSpawnInterval(t.units);
      final typeMod = t.unitType.spawnRateModifier;
      final levelMod = 1.0 - (t.level - 1) * 0.02;
      final effectiveSpawn = (spawnBase * typeMod * levelMod).clamp(0.12, 10.0);
      final burst = (baseBurstChance(t.units) + t.unitType.burstChanceAdd + t.level * 0.006).clamp(0.0, 1.0);
      final shield = (baseShieldChance(t.units) + t.unitType.shieldChanceAdd + t.level * 0.004).clamp(0.0, 1.0);
      final text = 'T${t.id} ${t.owner.toString().split(".").last} | units:${t.units} | sp:${effectiveSpawn.toStringAsFixed(2)}s b:${(burst*100).round()}% s:${(shield*100).round()}% ${t.isMax ? "MAX" : ""}';
      final tp = TextPainter(text: TextSpan(text: text, style: const TextStyle(color: Colors.white70, fontSize: 11)), textDirection: TextDirection.ltr)
        ..layout(maxWidth: hudWidth - 12);
      tp.paint(canvas, Offset(hudX + 6, y));
      y += 18.0;
    }
  }

  void _drawArrow(Canvas canvas, Offset a, Offset b) {
    final dir = (b - a);
    final dist = dir.distance;
    if (dist < 20) return;
    final unit = dir / dist;
    final mid = a + unit * (dist * 0.52);
    final perp = Offset(-unit.dy, unit.dx);
    final arrowSize = 8.0;
    final p1 = mid - unit * arrowSize + perp * (arrowSize * 0.6);
    final p2 = mid - unit * arrowSize - perp * (arrowSize * 0.6);
    final path = Path()..moveTo(mid.dx, mid.dy)..lineTo(p1.dx, p1.dy)..lineTo(p2.dx, p2.dy)..close();
    canvas.drawPath(path, Paint()..color = Colors.white24);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}
